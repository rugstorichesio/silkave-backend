// Silk Ave - Game Companion Script

// Initialize game state
let btc = 100
const glock = false
const cycle = 1
const inventory = {}
const currentPrices = {}
const eventCode = ""
const isRollCard = false
const blockBuying = false
const blockSelling = false
const bannedItem = null
const inventoryLimit = 20
const gameHistory = []
const ignoreNextNegative = false // For card 022 - Silk Security Patch
let sortInventoryBy = "none" // For sorting inventory: none, name, quantity, value

// Game flow state tracking
let gameFlowState = "enterEventCode"

const items = ["lsd", "weed", "cocaine", "mdma", "passports", "accounts", "ccs", "files"]
const itemNames = {
  lsd: "LSD",
  weed: "Weed",
  cocaine: "Cocaine",
  mdma: "MDMA",
  passports: "Forged Passports",
  accounts: "Hacked Accounts",
  ccs: "Skimmed Credit Cards",
  files: "Leaked Intel",
}
const priceMatrix = {
  lsd: [1, 1, 2, 3, 4, 5],
  weed: [1, 2, 3, 3, 4, 5],
  cocaine: [4, 5, 6, 7, 8, 9],
  mdma: [3, 4, 5, 6, 7, 8],
  passports: [2, 3, 4, 5, 6, 7],
  accounts: [3, 4, 5, 6, 7, 8],
  ccs: [2, 3, 5, 6, 7, 9],
  files: [4, 5, 6, 7, 8, 10],
}

// Initialize the game when the page loads
document.addEventListener("DOMContentLoaded", () => {
  updateStatusBars()
  updateInventoryDisplay()
  updateMarketTable()
  log("Welcome to Silk Ave. You start with 100 BTC. Good luck.")

  // Add event listener for event code input
  document.getElementById("eventCode").addEventListener("input", function () {
    if (this.value.length === 3 && gameFlowState === "enterEventCode") {
      gameFlowState = "applyEvent"
      updateGameFlowHighlight()
    }
  })

  // Start the guided highlighting
  updateGameFlowHighlight()

  // Play bleep sound when buttons are clicked
  try {
    const buttons = document.querySelectorAll("button")
    buttons.forEach((button) => {
      button.addEventListener("click", () => {
        playSound("bleep")
      })
    })
  } catch (e) {
    console.error("Error setting up sound:", e)
  }

  // Set initial button text based on cycle
  const advanceButton = document.getElementById("advanceCycleBtn")
  if (advanceButton && cycle === 10) {
    advanceButton.textContent = "Cash Out and Go Dark"
  }

  // Add sorting options to inventory display
  addSortingOptions()
})

// Add sorting options to the inventory display
function addSortingOptions() {
  const inventoryStatus = document.getElementById("inventoryStatus")
  if (!inventoryStatus) return

  // Create sorting options container
  const sortingOptions = document.createElement("div")
  sortingOptions.className = "sorting-options"
  sortingOptions.style.marginBottom = "10px"
  sortingOptions.style.textAlign = "right"

  // Create sort label
  const sortLabel = document.createElement("span")
  sortLabel.textContent = "Sort by: "
  sortingOptions.appendChild(sortLabel)

  // Create sort buttons
  const sortOptions = [
    { id: "none", text: "Default" },
    { id: "name", text: "Name" },
    { id: "quantity", text: "Quantity" },
    { id: "value", text: "Value" },
    { id: "profit", text: "Profit" },
  ]

  sortOptions.forEach((option) => {
    const button = document.createElement("button")
    button.textContent = option.text
    button.style.padding = "2px 5px"
    button.style.marginLeft = "5px"
    button.style.fontSize = "0.8rem"
    button.onclick = () => {
      sortInventoryBy = option.id
      updateInventoryDisplay()

      // Highlight the active sort button
      sortingOptions.querySelectorAll("button").forEach((btn) => {
        btn.style.backgroundColor = "#000"
        btn.style.color = "#0f0"
      })
      button.style.backgroundColor = "#0f0"
      button.style.color = "#000"
    }
    sortingOptions.appendChild(button)
  })

  // Insert sorting options before inventory status content
  inventoryStatus.parentNode.insertBefore(sortingOptions, inventoryStatus)
}

// Update status bars with current game state
function updateStatusBars() {
  document.getElementById("btc").textContent = btc
  document.getElementById("glock").textContent = glock ? "Yes" : "No"
  document.getElementById("cycle").textContent = cycle
  document.getElementById("invCount").textContent = countInventory()

  // Update liquid BTC display
  const liquidBtcElement = document.getElementById("liquid-btc")
  if (liquidBtcElement) {
    liquidBtcElement.textContent = btc
  }
}

// Count total inventory items
function countInventory() {
  let total = 0
  for (const item in inventory) {
    if (inventory.hasOwnProperty(item)) {
      total += inventory[item].length
    }
  }
  return total
}

// Calculate total inventory value
function calculateInventoryValue() {
  let totalValue = 0
  let totalCost = 0

  for (const item in inventory) {
    if (inventory.hasOwnProperty(item) && inventory[item].length > 0) {
      // Calculate current value based on market price
      const currentValue = inventory[item].length * (currentPrices[item] || 0)
      totalValue += currentValue

      // Calculate original cost
      const originalCost = inventory[item].reduce((sum, price) => sum + price, 0)
      totalCost += originalCost
    }
  }

  return {
    value: totalValue,
    cost: totalCost,
    profit: totalValue - totalCost,
  }
}

// Update inventory display with color coding and profit indicators
function updateInventoryDisplay() {
  const inventoryStatus = document.getElementById("inventoryStatus")
  if (!inventoryStatus) return

  // Get inventory items as an array for sorting
  const inventoryItems = []
  for (const item of items) {
    const itemInventory = inventory[item] || []
    if (itemInventory.length > 0) {
      // Calculate average purchase price
      const totalCost = itemInventory.reduce((sum, price) => sum + price, 0)
      const avgPrice = totalCost / itemInventory.length

      // Calculate current value and profit
      const currentValue = itemInventory.length * (currentPrices[item] || 0)
      const profit = currentValue - totalCost
      const profitPercent = totalCost > 0 ? (profit / totalCost) * 100 : 0

      inventoryItems.push({
        name: itemNames[item],
        key: item,
        count: itemInventory.length,
        avgPrice: avgPrice,
        currentPrice: currentPrices[item] || 0,
        totalCost: totalCost,
        currentValue: currentValue,
        profit: profit,
        profitPercent: profitPercent,
        prices: itemInventory,
      })
    }
  }

  // Sort inventory items based on selected sort option
  if (sortInventoryBy === "name") {
    inventoryItems.sort((a, b) => a.name.localeCompare(b.name))
  } else if (sortInventoryBy === "quantity") {
    inventoryItems.sort((a, b) => b.count - a.count)
  } else if (sortInventoryBy === "value") {
    inventoryItems.sort((a, b) => b.currentValue - a.currentValue)
  } else if (sortInventoryBy === "profit") {
    inventoryItems.sort((a, b) => b.profit - a.profit)
  }

  // Calculate total inventory value
  const inventoryValue = calculateInventoryValue()

  // Build inventory display text
  let inventoryText = "Current Inventory:\n"

  if (inventoryItems.length === 0) {
    inventoryText += "Empty"
  } else {
    // Add inventory items with color coding and profit indicators
    for (const item of inventoryItems) {
      // Determine color based on profit
      let itemColor = "#0f0" // Default green
      let profitIndicator = ""

      if (item.currentPrice > 0) {
        if (item.profit > 0) {
          itemColor = "#0f0" // Green for profit
          profitIndicator = `+${item.profit.toFixed(1)} BTC (+${item.profitPercent.toFixed(0)}%)`
        } else if (item.profit < 0) {
          itemColor = "#f00" // Red for loss
          profitIndicator = `${item.profit.toFixed(1)} BTC (${item.profitPercent.toFixed(0)}%)`
        } else {
          itemColor = "#ff0" // Yellow for break-even
          profitIndicator = "±0 BTC (0%)"
        }
      }

      // Format the item line with color and profit indicator
      inventoryText += `<span style="color:${itemColor}">${item.name}: ${item.count} (bought @ ${item.avgPrice.toFixed(1)} BTC each)`

      if (item.currentPrice > 0) {
        inventoryText += ` → current: ${item.currentPrice} BTC [${profitIndicator}]`
      }

      // Add individual prices if there are few items
      if (item.count <= 5) {
        inventoryText += ` [${item.prices.join(", ")} BTC]`
      }

      inventoryText += "</span>\n"
    }

    // Add total inventory value and profit
    inventoryText += `\nTotal inventory value: ${inventoryValue.value.toFixed(1)} BTC`
    if (inventoryValue.profit !== 0) {
      const profitColor = inventoryValue.profit > 0 ? "#0f0" : "#f00"
      const profitSign = inventoryValue.profit > 0 ? "+" : ""
      inventoryText += ` <span style="color:${profitColor}">(${profitSign}${inventoryValue.profit.toFixed(1)} BTC)</span>`
    }
  }

  // Set the HTML content to enable colored text
  inventoryStatus.innerHTML = inventoryText

  // Update the owned quantities in the transaction table
  for (const item of items) {
    const ownedElement = document.getElementById(`owned-${item}`)
    if (ownedElement) {
      const itemCount = (inventory[item] || []).length
      ownedElement.textContent = itemCount

      // Highlight if player owns any
      if (itemCount > 0) {
        ownedElement.style.color = "#0f0"
        ownedElement.style.fontWeight = "bold"
      } else {
        ownedElement.style.color = ""
        ownedElement.style.fontWeight = ""
      }
    }
  }
}

// Update market table with current prices and profit indicators
function updateMarketTable() {
  const tableBody = document.querySelector("#marketTable tbody")
  if (!tableBody) return

  tableBody.innerHTML = ""

  // Get the current burner deal
  const burnerItem = document.getElementById("burnerDeal").value

  for (const item of items) {
    const row = document.createElement("tr")

    // Item name cell
    const nameCell = document.createElement("td")
    nameCell.textContent = itemNames[item]

    // Highlight burner deal item
    if (item === burnerItem) {
      nameCell.classList.add("burner-deal-item")
    }

    if (item === bannedItem) {
      nameCell.style.textDecoration = "line-through"
      nameCell.style.color = "red"
    }
    row.appendChild(nameCell)

    // Price cell
    const priceCell = document.createElement("td")
    priceCell.textContent = currentPrices[item] ? `${currentPrices[item]} BTC` : "—"

    // Highlight profitable items
    if (inventory[item] && inventory[item].length > 0) {
      const avgCost = inventory[item].reduce((sum, price) => sum + price, 0) / inventory[item].length

      if (currentPrices[item] > avgCost) {
        // Profit
        const profit = currentPrices[item] - avgCost
        const profitPercent = (profit / avgCost) * 100

        priceCell.style.color = "#0f0" // Green for profit
        priceCell.style.fontWeight = "bold"

        // Add profit indicator
        const profitIndicator = document.createElement("span")
        profitIndicator.textContent = ` +${profitPercent.toFixed(0)}%`
        profitIndicator.style.fontSize = "0.8em"
        priceCell.appendChild(profitIndicator)
      } else if (currentPrices[item] < avgCost) {
        // Loss
        const loss = avgCost - currentPrices[item]
        const lossPercent = (loss / avgCost) * 100

        priceCell.style.color = "#f00" // Red for loss

        // Add loss indicator
        const lossIndicator = document.createElement("span")
        lossIndicator.textContent = ` -${lossPercent.toFixed(0)}%`
        lossIndicator.style.fontSize = "0.8em"
        priceCell.appendChild(lossIndicator)
      }
    }

    row.appendChild(priceCell)

    tableBody.appendChild(row)
  }
}

// Play a sound
function playSound(soundId) {
  try {
    const sound = document.getElementById(soundId)
    if (sound) {
      sound.currentTime = 0
      sound.play().catch((e) => console.log("Audio play failed:", e))
    }
  } catch (e) {
    console.error("Error playing sound:", e)
  }
}

// Log a message to the game log
function log(message) {
  const logElement = document.getElementById("log")
  if (!logElement) return

  // Add timestamp to log message
  const now = new Date()
  const timestamp = `[${now.getHours().toString().padStart(2, "0")}:${now.getMinutes().toString().padStart(2, "0")}:${now.getSeconds().toString().padStart(2, "0")}]`

  // Add the message to the log
  logElement.innerHTML += `${timestamp} ${message}\n`

  // Auto-scroll to the bottom
  logElement.scrollTop = logElement.scrollHeight
}

// Update the highlighted element based on game flow state
function updateGameFlowHighlight() {
  // Remove highlight from all elements
  const allElements = document.querySelectorAll(".highlight-pulse")
  allElements.forEach((el) => {
    el.classList.remove("highlight-pulse")
  })

  // Add highlight based on current state
  switch (gameFlowState) {
    case "enterEventCode":
      highlightElement("eventCodeSection")
      showHint("Enter a 3-digit event card code")
      break
    case "applyEvent":
      highlightElement("applyEventBtn")
      showHint("Apply the event card")
      break
    case "rollCard":
      highlightElement("rollCardBtn")
      showHint("Roll the dice for this card")
      break
    case "rollMarket":
      highlightElement("rollMarketBtn")
      showHint("Roll the market prices")
      break
    case "selectBurner":
      highlightElement("burnerDealSection")
      showHint("Select an item for burner deal (optional)")
      break
    case "applyBurner":
      highlightElement("applyBurnerBtn")
      showHint("Apply the burner deal")
      break
    case "executeTransactions":
      // Highlight both the transaction section and execute button
      highlightElement("transactionSection")
      highlightElement("executeTransactionsBtn")
      showHint("Enter buy/sell quantities and execute transactions")
      break
    case "advanceCycle":
      highlightElement("advanceCycleBtn")
      showHint(cycle === 10 ? "Cash out and complete the game" : "Advance to the next cycle")
      break
    default:
      hideHint()
      break
  }
}

// Show a hint message
function showHint(message) {
  const hintElement = document.getElementById("gameHint")
  if (hintElement) {
    hintElement.textContent = message
    hintElement.style.display = "block"
  }
}

// Hide the hint message
function hideHint() {
  const hintElement = document.getElementById("gameHint")
  if (hintElement) {
    hintElement.style.display = "none"
  }
}

// Highlight an element with a pulsing effect
function highlightElement(elementId) {
  const element = document.getElementById(elementId)
  if (element) {
    element.classList.add("highlight-pulse")
  }
}

// Set maximum buy amount for an item
function setMaxBuy(item) {
  if (blockBuying) {
    log("-- Cannot buy this round due to event effect.")
    return
  }

  if (!currentPrices[item]) {
    log("-- Cannot determine max buy. Roll market prices first.")
    return
  }

  // Calculate available inventory space
  const currentInventoryCount = countInventory()
  const spaceLeft = inventoryLimit - currentInventoryCount

  if (spaceLeft <= 0) {
    log("-- Inventory is full. Cannot buy more items.")
    return
  }

  // Calculate how many items can be afforded with current BTC
  const itemPrice = currentPrices[item]
  const affordableCount = Math.floor(btc / itemPrice)

  // The max buy is the minimum of space left and affordable count
  const maxBuy = Math.min(spaceLeft, affordableCount)

  // Set the input value
  const buyInput = document.getElementById(`buy-${item}`)
  if (buyInput) {
    buyInput.value = maxBuy
  }

  if (maxBuy === 0) {
    log(`-- Cannot afford any ${itemNames[item]} at current price (${itemPrice} BTC).`)
  } else if (maxBuy < affordableCount) {
    log(`-- Can buy up to ${maxBuy} ${itemNames[item]} (limited by inventory space).`)
  } else {
    log(`-- Can buy up to ${maxBuy} ${itemNames[item]} for ${maxBuy * itemPrice} BTC.`)
  }
}

// Set maximum sell amount for an item
function setMaxSell(item) {
  if (blockSelling) {
    log("-- Cannot sell this round due to event effect.")
    return
  }

  const itemInventory = inventory[item] || []
  const count = itemInventory.length

  if (count === 0) {
    log(`-- No ${itemNames[item]} in inventory to sell.`)
    return
  }

  // Set the input value to the number of items in inventory
  const sellInput = document.getElementById(`sell-${item}`)
  if (sellInput) {
    sellInput.value = count
  }

  // Calculate potential earnings
  const potentialEarnings = count * (currentPrices[item] || 1)
  log(`-- Set to sell all ${count} ${itemNames[item]} for ${potentialEarnings} BTC.`)
}

// Execute buy/sell transactions
function executeTransactions() {
  playSound("bleep")

  if (blockBuying && blockSelling) {
    log("-- Cannot buy or sell this round due to event effect.")
    return
  }

  let totalBought = 0
  let totalSold = 0
  let btcSpent = 0
  let btcEarned = 0

  // Process sells first (to free up inventory space)
  if (!blockSelling) {
    for (const item of items) {
      if (item === bannedItem) continue

      const sellInput = document.getElementById(`sell-${item}`)
      if (!sellInput) continue

      const sellAmount = Number.parseInt(sellInput.value) || 0

      if (sellAmount > 0) {
        const itemInventory = inventory[item] || []
        if (sellAmount > itemInventory.length) {
          log(`-- Error: Cannot sell ${sellAmount} ${itemNames[item]}. You only have ${itemInventory.length}.`)
          continue
        }

        // Remove items from inventory and add BTC
        const itemsToSell = Math.min(sellAmount, itemInventory.length)
        const earnings = itemsToSell * (currentPrices[item] || 1)

        // Remove the items from inventory
        inventory[item] = itemInventory.slice(0, itemInventory.length - itemsToSell)

        btcEarned += earnings
        totalSold += itemsToSell

        log(`-- Sold ${itemsToSell} ${itemNames[item]} for ${earnings} BTC.`)

        // Reset input
        sellInput.value = ""
      }
    }
  }

  // Update BTC after selling
  btc += btcEarned

  // Process buys
  if (!blockBuying) {
    for (const item of items) {
      if (item === bannedItem) continue

      const buyInput = document.getElementById(`buy-${item}`)
      if (!buyInput) continue

      const buyAmount = Number.parseInt(buyInput.value) || 0

      if (buyAmount > 0) {
        const cost = buyAmount * (currentPrices[item] || 1)

        // Check if player has enough BTC
        if (cost > btc) {
          log(`-- Error: Cannot afford ${buyAmount} ${itemNames[item]}.`)
          continue
        }

        // Check if there is enough space in inventory
        const currentInventoryCount = countInventory()
        const spaceLeft = inventoryLimit - currentInventoryCount

        if (buyAmount > spaceLeft) {
          log(`-- Error: Not enough space in inventory to buy ${buyAmount} ${itemNames[item]}.`)
          continue
        }

        // Add items to inventory and subtract BTC
        if (!inventory[item]) {
          inventory[item] = []
        }

        for (let i = 0; i < buyAmount; i++) {
          inventory[item].push(currentPrices[item] || 1)
        }

        btc -= cost
        btcSpent += cost
        totalBought += buyAmount

        log(`-- Bought ${buyAmount} ${itemNames[item]} for ${cost} BTC.`)

        // Reset input
        buyInput.value = ""
      }
    }
  }

  // Log transaction summary
  if (totalBought > 0 || totalSold > 0) {
    log(
      `-- Transaction summary: Bought ${totalBought} items for ${btcSpent} BTC, Sold ${totalSold} items for ${btcEarned} BTC.`,
    )
  } else {
    log("-- No transactions executed.")
  }

  updateInventoryDisplay()
  updateStatusBars()
  updateMarketTable()

  // Update game flow state
  gameFlowState = "advanceCycle"

  // Update the highlighted element
  updateGameFlowHighlight()
}

// Buy items (wrapper for executeTransactions)
function buyItems() {
  executeTransactions()
}

// Sell items (wrapper for executeTransactions)
function sellItems() {
  executeTransactions()
}

// Clear inventory
function clearInventory() {
  for (const item of items) {
    inventory[item] = []
  }
  updateInventoryDisplay()
  log("-- Inventory cleared.")
}

// Halve all prices
function halvePrices() {
  for (const item of items) {
    if (currentPrices[item]) {
      currentPrices[item] = Math.max(1, Math.floor(currentPrices[item] / 2))
    }
  }
  updateMarketTable()
  log("-- All prices halved.")
  return currentPrices
}

// Double all prices
function doublePrices() {
  for (const item of items) {
    if (currentPrices[item]) {
      currentPrices[item] = currentPrices[item] * 2
    }
  }
  updateMarketTable()
  log("-- All prices doubled.")
  return currentPrices
}

// Scroll to top
function scrollToTop() {
  window.scrollTo({
    top: 0,
    behavior: "smooth", // For a smooth scrolling effect
  })
}

// Generate a game hash for verification
function generateGameHash() {
  const gameData = {
    btc: btc,
    glock: glock,
    cycle: cycle,
    inventory: JSON.stringify(inventory),
  }

  // Simple hash function
  let hash = 0
  const str = JSON.stringify(gameData)
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i)
    hash = (hash << 5) - hash + char
    hash = hash & hash // Convert to 32bit integer
  }

  // Convert to hex and ensure it's positive
  return Math.abs(hash).toString(16).padStart(8, "0")
}
